
;   VERSION 0002
        NAME    INIT3
        
        ASSUME  CS:CODE,DS:DATA
        
DATA    SEGMENT PUBLIC
DATA    ENDS

CODE    SEGMENT PUBLIC
	EXTRN	@HLT : NEAR

	PUBLIC	INIPC
        PUBLIC  @INI3

INIPC	PROC	FAR
;
; this routine is adapted for PCDOS.
;
	MOV	AX,CS
	ADD	AX,CS:WORD PTR [3]	;ADD CODE SIZE
	ADD	AX,CS:WORD PTR [5]	;ADD DATA SIZE
	ADD	AX,CS:WORD PTR [7]	;ADD STACK SIZE
	ADD	AX,CS:WORD PTR [9]	;ADD EXTRA SIZE
	CMP	AX,DS:WORD PTR [2]	;COMPARE WITH MAX MEMORY
	JNA 	MEMOK	
	PUSH	DS	;SAVE ADDRESS OF PSP
	CALL	OUTOFMEM
	DB	'OUT OF MEMORY'
	DB	0AH
	DB	0DH
	DB	'$'
OUTOFMEM:
	MOV	AX,CS	;SET OF DS:DX TO POINT TO MESSAGE
	MOV	DS,AX 
	POP	DX
	MOV	AH,09	;DO PRINT STRING
	INT	021H
	XOR	AX,AX	;SEGMENT ADDRESS OF PSP IS ON STACK BECAUSE WE
			;PUSHED DS ABOVE
	PUSH	AX	;PUSH OFFSET=0 ONTO STACK
	RET		;AND TERMINATE THROUGH PSP
MEMOK:
;
; MEMORY IS AVAILABLE. SET UP BASE PAGE
;
; DETERMINE DS LOCATION
	MOV	AX,CS
	ADD	AX,CS:WORD PTR [3]	;ADD CODE SIZE TO GET BASE OF DATA
; COPY PROGRAM SEGMENT PREFIX TO BASE PAGE
	MOV	ES,AX
	MOV 	DI,0
	MOV	SI,DI
	CLD
	MOV 	CX,100H
	REP
	MOVSB
; SAVE PSP ADDRESS IN BASE PAGE
	MOV	ES:WORD PTR [40H],DS
; SET UP DS REGISTER
	MOV	DS,AX
; SAVE ADDRESS OF DATA IN BASE PAGE
	MOV	WORD PTR [09H],DS
; COMPUTE BASE OF EXTRA SEGMENT
	ADD	AX,CS:WORD PTR [5]	;ADD SIZE OF DATA
	MOV	WORD PTR [0FH],AX	
;COMPUTE BASE OF STACK
	ADD	AX,CS:WORD PTR [09H]	;ADD LENGTH OF EXTRA
	MOV	WORD PTR [15H],AX
	MOV	CX,4	;CONVERT STACK SIZE FROM PARA TO BYTES
	MOV	BX,CS:WORD PTR [07H]
	SHL	BX,CL
	MOV	WORD PTR [12H],BX	;SAVE IN BASE PAGE
;SET UP STACK POINTERS
	PUSHF
	POP	DX
	CLI
	MOV	SS,AX
	MOV	SP,BX
	STI
	PUSH	DX
	POPF
;
;NOW CHANGE SIZES TO BYTES NOT PARAGRAPHS.
; AND SAVE IN BASE PAGE
;
	MOV	AX,CS:WORD PTR [5]	;GET DATA SIZE
	MOV	CL,04
	SHL	AX,CL
	MOV	WORD PTR [06],AX
	MOV	AX,CS:WORD PTR [09H]		;GET EXTRA SIZE
	MOV	BX,AX		;SAVE SIZE
	MOV	CL,04
	SHL	AX,CL
	MOV	WORD PTR [0CH],AX		;SAVE LOW ORDER BYTES
	MOV	AX,BX
	MOV	CL,12
	SHR	AX,CL
	MOV	BYTE PTR [0EH],AL		;SAVE TOP BYTE
	MOV	AX,CS
	ADD	AX,8
	PUSH	AX
	XOR	AX,AX
	PUSH	AX
	RET		;RETURN TO MAIN PROGRAM
INIPC	ENDP



@INI3   PROC    NEAR
        MOV     AX,DS
        MOV     ES,AX   ;NOW ES:0 IS START OF DATA AREA
        MOV     DI,6    ;6 IS OFFSET OF DSEG LENGTH
        MOV     CX,ES:WORD PTR [DI]
        SUB     CX,100H ;SEGMENT LENGTH IS IN BYTES
        MOV     DI,100H ;START ADDRESS OF FILL
        XOR     AX,AX   ;DATA TO FILL WITH
        REP
        STOSB           ;ZERO IT ALL
        
;
;       NOW IF OVERLAYS ARE LINKED INTO THE ROOT ZERO THE FIRST
;       BYTE OF THE OVERLAY AREAS
;
        MOV     AX,CS
        MOV     ES,AX   ;NOW CS:0 IS START OF CODE
        MOV     DI,0CH  ;0C IS OFFSET OF NAME CONTROL BLOCK
        MOV     AX,ES:WORD PTR [DI]
        MOV     BX,ES:WORD PTR 2[DI]
;
;       IF AX=BX THEN OVERLAYS WERE NOT LINKED INTO THIS PROGRAM
;
        CMP     AX,BX
        JZ      XIT
        
        MOV     DI,BX   ;ELSE EI:DI NOW POINTS TO OVERLAY AREA TABLE
        MOV     CX,16   ;NUMBER OF ENTRIES IN THE TABLE

LP:     MOV     SI,ES:WORD PTR [DI] ;GET OFFSET OF OVERLAY AREA
        MOV     ES:BYTE PTR [SI],0  ;PUT A ZERO THERE
        INC     DI                  ;AND BUMP TO NEXT OFFSET IN TABLE
        INC     DI
        LOOP    LP                  ;DO IT 16 TIMES

XIT:    RET
        
@INI3   ENDP

CODE    ENDS

        END
        

